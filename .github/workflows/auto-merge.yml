name: Auto-merge PRs

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  check_suite:
    types: [completed]
  status:

jobs:
  auto-merge:
    name: Enable Auto-merge
    runs-on: self-hosted
    # Only run on pull requests
    if: github.event.pull_request != '' || (github.event.check_suite != '' && github.event.check_suite.pull_requests.length > 0)
    permissions:
      contents: write
      pull-requests: write
      checks: read
    steps:
      - name: Get PR number
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber;

            if (context.payload.pull_request) {
              prNumber = context.payload.pull_request.number;
            } else if (context.payload.check_suite && context.payload.check_suite.pull_requests.length > 0) {
              prNumber = context.payload.check_suite.pull_requests[0].number;
            } else if (context.payload.status) {
              // For status events, we need to find the PR from the commit
              const commitSha = context.payload.sha || context.payload.commit?.sha;
              if (commitSha) {
                const { data: pulls } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: commitSha
                });
                if (pulls.length > 0) {
                  prNumber = pulls[0].number;
                }
              }
            }

            if (!prNumber) {
              core.setFailed('Could not determine PR number');
              return;
            }

            core.setOutput('number', prNumber);
            return prNumber;

      - name: Check PR status and enable auto-merge
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            // Skip if PR is already merged or closed
            if (pr.state !== 'open') {
              console.log(`PR #${prNumber} is ${pr.state}, skipping auto-merge`);
              return;
            }

            // Skip if PR is a draft
            if (pr.draft) {
              console.log(`PR #${prNumber} is a draft, skipping auto-merge`);
              return;
            }

            // Check if auto-merge is already enabled
            if (pr.auto_merge) {
              console.log(`Auto-merge already enabled for PR #${prNumber}`);
              return;
            }

            // Get the mergeable state
            // Note: mergeable_state can be: clean, dirty, unstable, blocked, behind, or unknown
            // We want to enable auto-merge when state is 'clean'
            if (pr.mergeable_state === 'clean' && pr.mergeable === true) {
              try {
                // Enable auto-merge with squash merge (change to 'merge' or 'rebase' if preferred)
                await github.rest.pulls.enableAutoMerge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });

                console.log(`âœ… Enabled auto-merge for PR #${prNumber}`);
              } catch (error) {
                if (error.status === 404 || error.message.includes('Auto-merge is not available')) {
                  console.log(`Auto-merge not available for PR #${prNumber} (may require branch protection or other settings)`);
                } else if (error.status === 409) {
                  console.log(`Auto-merge already enabled for PR #${prNumber}`);
                } else {
                  console.error(`Error enabling auto-merge: ${error.message}`);
                  throw error;
                }
              }
            } else {
              // Provide detailed diagnostic information about why PR is blocked
              console.log(`PR #${prNumber} is not ready for merge. State: ${pr.mergeable_state}, Mergeable: ${pr.mergeable}`);

              // Get more details about what's blocking
              const reasons = [];

              if (pr.mergeable_state === 'blocked') {
                reasons.push('Branch protection requirements not met');

                // Check status checks
                const { data: statuses } = await github.rest.repos.getCombinedStatusForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha
                });

                const failingChecks = statuses.statuses.filter(s => s.state === 'failure' || s.state === 'error');
                if (failingChecks.length > 0) {
                  reasons.push(`Failing status checks: ${failingChecks.map(c => c.context).join(', ')}`);
                }

                // Check if branch is behind
                const { data: compare } = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: pr.base.sha,
                  head: pr.head.sha
                });
                if (compare.behind_by > 0) {
                  reasons.push(`Branch is ${compare.behind_by} commit(s) behind base branch`);
                }

                // Check review status
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                const approvals = reviews.filter(r => r.state === 'APPROVED');
                if (approvals.length === 0) {
                  reasons.push('No approvals yet (requires 1 approval)');
                }
              } else if (pr.mergeable_state === 'behind') {
                reasons.push('Branch is behind the base branch');
              } else if (pr.mergeable_state === 'dirty') {
                reasons.push('Merge conflicts detected');
              } else if (pr.mergeable_state === 'unstable') {
                reasons.push('Status checks are still running or unstable');
              } else if (pr.mergeable_state === 'unknown') {
                reasons.push('Mergeable state is unknown (GitHub is still calculating)');
              }

              if (reasons.length > 0) {
                console.log(`Blocking reasons:`);
                reasons.forEach(reason => console.log(`  - ${reason}`));
              }

              console.log(`Waiting for all checks to pass and requirements to be met...`);
            }

