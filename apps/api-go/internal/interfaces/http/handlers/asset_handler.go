package handlers

import (
	"bytes"
	"net/http"
	"path/filepath"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/sacred-vows/api-go/internal/infrastructure/storage"
	"github.com/sacred-vows/api-go/internal/usecase/asset"
	"github.com/sacred-vows/api-go/pkg/errors"
	"github.com/segmentio/ksuid"
)

type AssetHandler struct {
	uploadUC            *asset.UploadAssetUseCase
	getAllUC            *asset.GetAllAssetsUseCase
	deleteUC            *asset.DeleteAssetUseCase
	deleteByURLsUC      *asset.DeleteAssetsByURLsUseCase
	getByURLsUC         *asset.GetAssetsByURLsUseCase
	fileStorage         storage.Storage
	gcsStorage          storage.SignedURLStorage // Optional, for signed URL generation
	signedURLExpiration time.Duration
	imageProcessor      *storage.ImageProcessor // Optional, for image optimization
}

func NewAssetHandler(
	uploadUC *asset.UploadAssetUseCase,
	getAllUC *asset.GetAllAssetsUseCase,
	deleteUC *asset.DeleteAssetUseCase,
	deleteByURLsUC *asset.DeleteAssetsByURLsUseCase,
	getByURLsUC *asset.GetAssetsByURLsUseCase,
	fileStorage storage.Storage,
	gcsStorage storage.SignedURLStorage, // Optional, can be nil
	signedURLExpiration time.Duration,
	imageProcessor *storage.ImageProcessor, // Optional, can be nil
) *AssetHandler {
	return &AssetHandler{
		uploadUC:            uploadUC,
		getAllUC:            getAllUC,
		deleteUC:            deleteUC,
		deleteByURLsUC:      deleteByURLsUC,
		getByURLsUC:         getByURLsUC,
		fileStorage:         fileStorage,
		gcsStorage:          gcsStorage,
		signedURLExpiration: signedURLExpiration,
		imageProcessor:      imageProcessor,
	}
}

type DeleteAssetRequest struct {
	URL string `json:"url" binding:"required" example:"/uploads/abc123.jpg"`
}

type AssetDTO struct {
	ID           string `json:"id" example:"1234567890"`
	URL          string `json:"url" example:"/uploads/abc123.jpg"`
	Filename     string `json:"filename" example:"abc123.jpg"`
	OriginalName string `json:"originalName" example:"photo.jpg"`
	Size         int64  `json:"size" example:"1024000"`
	MimeType     string `json:"mimetype" example:"image/jpeg"`
	UserID       string `json:"userId" example:"user123"`
	CreatedAt    string `json:"createdAt" example:"2024-01-01T00:00:00Z"`
}

type UploadAssetResponse struct {
	URL   string    `json:"url" example:"/uploads/abc123.jpg"`
	Asset *AssetDTO `json:"asset"`
}

type AssetsResponse struct {
	Assets []AssetDTO `json:"assets"`
}

// Upload uploads a new asset file
// @Summary      Upload asset
// @Description  Upload a new asset file (image). Authentication is required.
// @Tags         assets
// @Accept       multipart/form-data
// @Produce      json
// @Security     BearerAuth
// @Param        image  formData  file    true  "Image file to upload"
// @Success      200    {object}  UploadAssetResponse  "Asset uploaded successfully"
// @Failure      400    {object}  ErrorResponse       "Invalid file or request"
// @Failure      401    {object}  ErrorResponse       "Authentication required"
// @Failure      500    {object}  ErrorResponse       "Internal server error"
// @Router       /assets/upload [post]
func (h *AssetHandler) Upload(c *gin.Context) {
	// Require authentication
	userID, exists := c.Get("userID")
	if !exists || userID == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	file, err := c.FormFile("image")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No file uploaded"})
		return
	}

	// Open file and read content into buffer
	src, err := file.Open()
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to open file"})
		return
	}
	defer src.Close()

	// Read file content into buffer (max 10MB, acceptable for images)
	fileContent := make([]byte, file.Size)
	_, err = src.Read(fileContent)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to read file"})
		return
	}

	// Validate file
	mimeType := file.Header.Get("Content-Type")
	if err := h.fileStorage.ValidateFile(mimeType, file.Size); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Process image if processor is available
	processedContent := bytes.NewReader(fileContent)
	finalSize := file.Size
	if h.imageProcessor != nil {
		processedReader, newSize, err := h.imageProcessor.ProcessImage(bytes.NewReader(fileContent), mimeType, file.Size)
		if err == nil && newSize > 0 {
			processedContent = processedReader.(*bytes.Reader)
			finalSize = newSize
		}
		// If processing fails, use original content
	}

	// Generate filename and create asset record first
	output, err := h.uploadUC.Execute(c.Request.Context(), asset.UploadAssetInput{
		Filename:     "", // Will be generated by use case
		OriginalName: file.Filename,
		Size:         finalSize,
		MimeType:     mimeType,
		UserID:       userID.(string),
	})

	if err != nil {
		appErr, ok := err.(*errors.AppError)
		if ok {
			c.JSON(appErr.Code, appErr.ToResponse())
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Upload failed"})
		return
	}

	// Reset reader to beginning
	processedContent.Seek(0, 0)

	// Save file to storage using the filename from use case and the processed content
	_, err = h.fileStorage.SaveFile(output.Filename, file.Filename, mimeType, finalSize, processedContent)
	if err != nil {
		// Clean up database record
		h.deleteUC.Execute(c.Request.Context(), output.URL)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Upload failed"})
		return
	}

	// Generate signed URL for GCS or S3 assets if using signed URL storage
	assetURL := output.URL
	if h.gcsStorage != nil {
		// For GCS/S3, use the filename (object key) to generate signed URL
		signedURL, err := h.gcsStorage.GenerateSignedURL(c.Request.Context(), output.Filename, "GET", h.signedURLExpiration)
		if err == nil {
			assetURL = signedURL
			// Update the asset DTO with the signed URL
			output.Asset.URL = signedURL
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"url":   assetURL,
		"asset": output.Asset,
	})
}

// GetAll retrieves all assets for the current user
// @Summary      List assets
// @Description  Get all assets for the current user. Authentication is required.
// @Tags         assets
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Success      200  {object}  AssetsResponse   "List of assets"
// @Failure      401  {object}  ErrorResponse   "Authentication required"
// @Failure      500  {object}  ErrorResponse   "Internal server error"
// @Router       /assets [get]
func (h *AssetHandler) GetAll(c *gin.Context) {
	// Require authentication
	userID, exists := c.Get("userID")
	if !exists || userID == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	output, err := h.getAllUC.Execute(c.Request.Context(), userID.(string))
	if err != nil {
		appErr, ok := err.(*errors.AppError)
		if ok {
			c.JSON(appErr.Code, appErr.ToResponse())
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get assets"})
		return
	}

	// Generate signed URLs for GCS/S3 assets if using signed URL storage
	if h.gcsStorage != nil {
		for i := range output.Assets {
			// For GCS/S3, use the filename to generate signed URL
			filename := output.Assets[i].Filename
			signedURL, err := h.gcsStorage.GenerateSignedURL(c.Request.Context(), filename, "GET", h.signedURLExpiration)
			if err == nil {
				output.Assets[i].URL = signedURL
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{"assets": output.Assets})
}

// Delete deletes an asset
// @Summary      Delete asset
// @Description  Delete an asset by URL. Authentication is required.
// @Tags         assets
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        request  body      DeleteAssetRequest  true  "Asset URL to delete"
// @Success      200      {object}  MessageResponse     "Asset deleted"
// @Failure      400      {object}  ErrorResponse       "Invalid request"
// @Failure      401      {object}  ErrorResponse       "Authentication required"
// @Failure      404      {object}  ErrorResponse       "Asset not found"
// @Router       /assets/delete [delete]
func (h *AssetHandler) Delete(c *gin.Context) {
	// Require authentication
	userID, exists := c.Get("userID")
	if !exists || userID == nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	var req DeleteAssetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "URL is required"})
		return
	}

	// Find asset to get filename for storage deletion
	asset, err := h.deleteUC.Execute(c.Request.Context(), req.URL)
	if err != nil {
		appErr, ok := err.(*errors.AppError)
		if ok {
			c.JSON(appErr.Code, appErr.ToResponse())
			return
		}
		c.JSON(http.StatusNotFound, gin.H{"error": "Asset not found"})
		return
	}

	// Delete from storage using the filename
	filename := asset.Filename
	if err := h.fileStorage.DeleteFile(filename); err != nil {
		// Log error but don't fail - asset is already deleted from DB
		c.JSON(http.StatusOK, gin.H{"message": "Asset deleted", "warning": "Storage deletion may have failed"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Asset deleted"})
}

type GenerateSignedURLRequest struct {
	Filename string `json:"filename" binding:"required" example:"abc123.jpg"`
	MimeType string `json:"mimeType" binding:"required" example:"image/jpeg"`
	Size     int64  `json:"size" binding:"required" example:"1024000"`
}

type GenerateSignedURLResponse struct {
	SignedURL string `json:"signedUrl" example:"https://storage.googleapis.com/..."`
	ObjectKey string `json:"objectKey" example:"abc123.jpg"`
	ExpiresIn int    `json:"expiresIn" example:"3600"`
}

// GenerateSignedURL generates a signed URL for direct upload to GCS
// @Summary      Generate signed URL for upload
// @Description  Generate a signed URL that allows direct upload to GCS. The client should use this URL to PUT the file directly to GCS.
// @Tags         assets
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        request  body      GenerateSignedURLRequest  true  "Upload request"
// @Success      200      {object}  GenerateSignedURLResponse  "Signed URL generated"
// @Failure      400      {object}  ErrorResponse             "Invalid request"
// @Failure      500      {object}  ErrorResponse             "Internal server error"
// @Router       /assets/upload-url [post]
func (h *AssetHandler) GenerateSignedURL(c *gin.Context) {
	if h.gcsStorage == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "Signed URL generation not available"})
		return
	}

	var req GenerateSignedURLRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	// Validate file
	if err := h.fileStorage.ValidateFile(req.MimeType, req.Size); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Generate unique filename
	ext := filepath.Ext(req.Filename)
	uniqueFilename := ksuid.New().String() + ext

	// Generate signed URL (valid for 1 hour)
	expiresIn := 1 * time.Hour
	signedURL, err := h.gcsStorage.GenerateSignedURL(c.Request.Context(), uniqueFilename, "PUT", expiresIn)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate signed URL"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"signedUrl": signedURL,
		"objectKey": uniqueFilename,
		"expiresIn": int(expiresIn.Seconds()),
	})
}

type CountAssetsByURLsRequest struct {
	URLs []string `json:"urls" binding:"required"`
}

type CountAssetsByURLsResponse struct {
	Count int `json:"count"`
}

// CountByURLs gets the count of assets by URLs
// @Summary      Count assets by URLs
// @Description  Get count of existing assets by their URLs. Authentication is required.
// @Tags         assets
// @Accept       json
// @Produce      json
// @Security     BearerAuth
// @Param        request  body      CountAssetsByURLsRequest  true  "Array of asset URLs"
// @Success      200      {object}  CountAssetsByURLsResponse  "Asset count"
// @Failure      400      {object}  ErrorResponse             "Invalid request"
// @Failure      401      {object}  ErrorResponse             "Authentication required"
// @Failure      500      {object}  ErrorResponse             "Internal server error"
// @Router       /assets/count-by-urls [post]
func (h *AssetHandler) CountByURLs(c *gin.Context) {
	// Require authentication
	_, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
		return
	}

	var req CountAssetsByURLsRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "URLs array is required"})
		return
	}

	output, err := h.getByURLsUC.Execute(c.Request.Context(), asset.GetAssetsByURLsInput{
		URLs: req.URLs,
	})
	if err != nil {
		appErr, ok := err.(*errors.AppError)
		if ok {
			c.JSON(appErr.Code, appErr.ToResponse())
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get asset count"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"count": output.Count})
}
